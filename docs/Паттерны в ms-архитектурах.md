- Polyglot persistence 
- Event Driven vs Command Driven
- Event Driven: Event Notification
- Event Carried state transfer
- Event Driven: Event Sourcing
- CQRS - не пиши туда, где читаешь
- [Gracefull degradation](https://youtu.be/5_9x7czHJOM):
  - Null object pattern
  - [Circuit breaker (каскадные timeout)](https://medium.com/@kirill.sereda/%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-circuit-breaker-pattern-650232944e37)
  - Health check + кэши спереди бэка под нагрузкой

## Retry

- ограничение на кол-во запросов (3 штуки)
- ограничение на таймаут (сколько с можем, но в рамках 200 сек)

### Exponential backoff и Jitter

Exponential backoff и jitter - это стратегии, используемые в сетевых и распределенных системах для управления повторными попытками выполнения операций при возникновении ошибок или задержек. Они помогают уменьшить нагрузку на сеть и улучшить производительность системы в условиях перегрузки или недоступности ресурсов.

Exponential Backoff (Экспоненциальное увеличение интервала между попытками): Это стратегия, при которой интервал времени между каждой последующей попыткой увеличивается в геометрической прогрессии. Например, после первой неудачной попытки может быть задержка в 1 секунду, затем 2 секунды, 4 секунды и так далее. Это позволяет системе избегать бесконечных попыток, которые могут перегрузить сервер или сеть, и дает ресурсам время восстановиться после перегрузки. Экспоненциальное увеличение также помогает снизить конфликты при одновременных повторных попытках.

Jitter (Случайная задержка): Jitter - это случайная задержка, которая добавляется к интервалам времени между попытками. Она используется для снижения сетевой нагрузки и уменьшения вероятности возникновения конфликтов при повторных попытках сразу после истечения задержки. Случайная задержка делает попытки менее синхронными и предотвращает перегрузку серверов при одновременных запросах от множества клиентов.

### Retry After

HTTP заголовок Retry-After используется для информирования клиента о времени, через которое можно будет повторить запрос к серверу, если текущий запрос был отклонен или сервер вернул статус ошибки, указывающий на временную недоступность ресурса или ограничения на запросы.

Этот заголовок имеет несколько важных применений:

Серверная перегрузка: Если сервер перегружен и не способен обработать запрос клиента в данный момент, он может вернуть статус ошибки, такой как 503 Service Unavailable, и включить заголовок Retry-After, чтобы указать, через сколько времени клиенту следует повторить запрос. Это помогает снизить нагрузку на сервер, разрешая клиентам повторять запросы через определенное время вместо бесконечных попыток.

Ограничения на запросы: Некоторые серверы или API могут иметь ограничения на количество запросов, которые клиент может отправить в определенный период времени. Если клиент превышает это ограничение, сервер может вернуть статус ошибки и указать в заголовке Retry-After, когда клиент может снова отправить запрос.

Предупреждение о временной недоступности: Retry-After также может использоваться для предупреждения клиентов о временной недоступности ресурса по плановым причинам, например, для обслуживания или обновления. Это позволяет клиентам заранее знать, когда ресурс снова будет доступен.

Клиенты могут использовать информацию из заголовка Retry-After, чтобы оптимально управлять повторными запросами и избегать избыточных запросов к серверу в случае временной недоступности. Это помогает улучшить эффективность и надежность взаимодействия между клиентами и серверами.

### Ключи идемпотентности

Ключи идемпотентности (Idempotency Keys) являются способом обеспечения идемпотентности операций при повторных попытках. Идемпотентность означает, что одна и та же операция, выполненная несколько раз, не приводит к различным результатам, как если бы она была выполнена только один раз.

Когда клиент отправляет запрос на сервер, и этот запрос потенциально может быть повторен из-за сетевых ошибок или других проблем, важно, чтобы сервер мог различать между первоначальным запросом и повторными запросами, чтобы избежать дублирования операций или нежелательных эффектов.

Ключи идемпотентности - это уникальные идентификаторы или значения, включенные в запрос, которые клиент генерирует и отправляет серверу при каждом запросе. Сервер сохраняет ключ идемпотентности для каждого запроса, который он получает, и использует его для определения того, был ли запрос обработан ранее. Если сервер видит ключ идемпотентности, который он уже обработал, то он может проигнорировать повторный запрос и вернуть результат, который был получен при первоначальной обработке.

Примеры ключей идемпотентности включают в себя случайно сгенерированные уникальные идентификаторы, хеши данных запроса или другие механизмы, которые обеспечивают уникальность идентификации запроса. Это позволяет клиентам отправлять повторные запросы без опасности вызвать нежелательные изменения состояния на сервере.

Использование ключей идемпотентности в комбинации с механизмом Retry позволяет обеспечивать безопасность и надежность взаимодействия между клиентом и сервером, даже если запросы повторяются из-за сетевых сбоев или других проблем.

> Важно помнить, что сетевые ошибки могут просиходить при Response, и [сервис может обработать запрос](https://youtu.be/YlXJMCdssAI?si=hL56XhGeawR-XV_D&t=791), хотя клиент получил ошибку.
