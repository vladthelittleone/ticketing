- Polyglot persistence 
- Event Driven vs Command Driven
- Event Driven: Event Notification
- Event Carried state transfer
- Event Driven: Event Sourcing
- CQRS - не пиши туда, где читаешь
- [Gracefull degradation](https://youtu.be/5_9x7czHJOM):
  - Null object pattern
  - [Circuit breaker (каскадные timeout)](https://medium.com/@kirill.sereda/%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-circuit-breaker-pattern-650232944e37)
  - Health check + кэши спереди бэка под нагрузкой

## Retry

- ограничение на кол-во запросов (3 штуки)
- ограничение на таймаут (сколько с можем, но в рамках 200 сек)

### Exponential backoff и Jitter

Exponential backoff и jitter - это стратегии, используемые в сетевых и распределенных системах для управления повторными попытками выполнения операций при возникновении ошибок или задержек. Они помогают уменьшить нагрузку на сеть и улучшить производительность системы в условиях перегрузки или недоступности ресурсов.

Exponential Backoff (Экспоненциальное увеличение интервала между попытками): Это стратегия, при которой интервал времени между каждой последующей попыткой увеличивается в геометрической прогрессии. Например, после первой неудачной попытки может быть задержка в 1 секунду, затем 2 секунды, 4 секунды и так далее. Это позволяет системе избегать бесконечных попыток, которые могут перегрузить сервер или сеть, и дает ресурсам время восстановиться после перегрузки. Экспоненциальное увеличение также помогает снизить конфликты при одновременных повторных попытках.

Jitter (Случайная задержка): Jitter - это случайная задержка, которая добавляется к интервалам времени между попытками. Она используется для снижения сетевой нагрузки и уменьшения вероятности возникновения конфликтов при повторных попытках сразу после истечения задержки. Случайная задержка делает попытки менее синхронными и предотвращает перегрузку серверов при одновременных запросах от множества клиентов.

### Retry After

HTTP заголовок Retry-After используется для информирования клиента о времени, через которое можно будет повторить запрос к серверу, если текущий запрос был отклонен или сервер вернул статус ошибки, указывающий на временную недоступность ресурса или ограничения на запросы.

Этот заголовок имеет несколько важных применений:

Серверная перегрузка: Если сервер перегружен и не способен обработать запрос клиента в данный момент, он может вернуть статус ошибки, такой как 503 Service Unavailable, и включить заголовок Retry-After, чтобы указать, через сколько времени клиенту следует повторить запрос. Это помогает снизить нагрузку на сервер, разрешая клиентам повторять запросы через определенное время вместо бесконечных попыток.

Ограничения на запросы: Некоторые серверы или API могут иметь ограничения на количество запросов, которые клиент может отправить в определенный период времени. Если клиент превышает это ограничение, сервер может вернуть статус ошибки и указать в заголовке Retry-After, когда клиент может снова отправить запрос.

Предупреждение о временной недоступности: Retry-After также может использоваться для предупреждения клиентов о временной недоступности ресурса по плановым причинам, например, для обслуживания или обновления. Это позволяет клиентам заранее знать, когда ресурс снова будет доступен.

Клиенты могут использовать информацию из заголовка Retry-After, чтобы оптимально управлять повторными запросами и избегать избыточных запросов к серверу в случае временной недоступности. Это помогает улучшить эффективность и надежность взаимодействия между клиентами и серверами.
